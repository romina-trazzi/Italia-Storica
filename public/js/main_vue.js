/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main_vue.js":
/*!*************************!*\
  !*** ./src/main_vue.js ***!
  \*************************/
/***/ (() => {

/*=============================================
    =            VUE SECTION           =
=============================================*/
Vue.config.devtools = true;
var app = new Vue({
  el: "#app",
  data: {
    counter: 0,
    images: ["public/img/carousel0.jpg", "public/img/carousel1.jpg", "public/img/carousel2.jpg", "public/img/carousel3.jpg", "public/img/carousel4.jpg"],
    libri: [{
      "titolo": "Il calderone delle streghe",
      "sottotitolo": "La battaglia della sacca di Cherkassy, gennaio-febbraio 1944",
      "autore": "Günther Jahnke, Bernd Lerch",
      "pagine": "492 p., ill. , Brossura",
      "anno di pubblicazione": "2021",
      "descrizione": "Il presente studio sulla 'Sacca di Cherkassy' è un'analisi operazionale e tattica. Vi sono descritte la sequenza degli avvenimenti e lo sviluppo della situazione militare del fronte tedesco a sud di Cherkassy dal 28 gennaio al 17 febbraio 1944. Viene anche data un'ampia panoramica del quadro generale di ciò che avvenne tra la fine del 1943 e l'inizio del 1944 sul fronte dell'Heeresgruppe Süd, per assicurare una migliore comprensione del contesto della battaglia, che si distinse per drammaticità e svolgimento tattico dal resto degli eventi del fronte orientale. Il presente lavoro si sforza di dare una rappresentazione fattuale e quanto più esauriente possibile, grazie alla consultazione di una vasta mole di documenti d'archivio e fonti secondarie tedesche e sovietiche, diari di guerra delle unità coinvolte e testimonianze dirette di veterani. In appendice, numerose fotografie rare e inedite della battaglia, e la riproduzione delle mappe originali tedesche delle operazioni nella sacca.",
      "prezzo": "34,20 euro",
      "link_IBS": "https://www.ibs.it/calderone-delle-streghe-battaglia-della-libro-gunther-jahnke-bernd-lerch/e/9788831430128"
    }, {
      "titolo": "La caduta di Berlino",
      "sottotitolo": "L'ultima battaglia di Hitler",
      "autore": "Werner Haupt",
      "pagine": "278 p., ill. , Brossura",
      "anno di pubblicazione": "2020",
      "descrizione": "Un classico della storia militare, coniugante l'accuratezza della documentata ricostruzione storica degli ultimi combattimenti per Berlino dell'aprile-maggio 1945, dallo sfondamento sovietico sull'Oder sino alla battaglia di Seelow e la difesa finale della capitale del III Reich, e l'avvincente narrazione delle vicende di un pugno di carristi della Panzer-Division 'Müncheberg' e volontari francesi dell'SS-Sturmbataillon 'Charlemagne', tra gli ultimi difensori di Berlino. Questa edizione presenta una traduzione rivista e annotata a cura del Wehrmacht Research Group, ed è integrata da nuove dettagliate mappe delle operazioni, drammatiche fotografie in azione dell'epoca, immagini attuali dei luoghi dei combattimenti e di illustrazioni a colori.",
      "prezzo": "23,75 euro",
      "link_IBS": "https://www.ibs.it/caduta-di-berlino-ultima-battaglia-libro-werner-haupt/e/9788831430012"
    }, {
      "titolo": "Il gladiatore di Hitler",
      "sottotitolo": "Vita e battaglie del Generale d'armata SS Sepp Dietrich",
      "autore": "Charles Messenger",
      "pagine": "492 p., ill. , Brossura",
      "anno di pubblicazione": "2021",
      "descrizione": "Veterano della prima guerra mondiale, dove servì nei primi reparti corazzati imperiali su Tank di preda bellica, e combattente nei Freikorps nei turbolenti anni della repubblica di Weimar, Josef 'Sepp' Dietrich fu uno dei primi sostenitori del Nazionalsocialismo tedesco, legando indissolubilmente la sua vita ad Adolf Hitler e la sua carriera militare alla guida dell'élite delle SS, la Leibstandarte SS Adolf Hitler, dirigendone la formazione e le attività nella Germania degli anni '30 e quindi guidandola in guerra nelle campagne di Polonia, Francia, Grecia e nei durissimi combattimenti sul fronte russo nel 1941-1943, per poi prendere il comando di Armate Panzer SS negli scontri finali in Normandia, Ardenne e Ungheria. Incensato dalla propaganda tedesca e diffamato da quella Alleata, condannato quale criminale di guerra, Sepp Dietrich fu un comandante devoto ai suoi uomini e li guidò in alcuni dei combattimenti più feroci della guerra. In questa prima edizione italiana, ampiamente illustrata, lo storico militare inglese Charles Messenger fornisce un resoconto obiettivo delle battaglie di Sepp Dietrich e delle sue Waffen-SS.",
      "prezzo": "27,55 euro",
      "link_IBS": "https://www.ibs.it/gladiatore-di-hitler-vita-battaglie-libro-charles-messenger/e/9788831430135"
    }, {
      "titolo": "Il vero volto del soldato tedesco",
      "sottotitolo": "",
      "autore": "Fritz Kempe",
      "pagine": "102 p., ill. , Brossura",
      "anno di pubblicazione": "2016",
      "descrizione": "Questo libro fotografico dedicato al Volto del soldato tedesco nella seconda guerra mondiale, curato dal fotografo Fritz Kempe (1909-1988) per conto dell'Oberkommando della Wehrmacht, il comando supremo delle forze armate, e pubblicato nel 1943, rappresentò, per qualità tecnica delle fotografie riprodotte e per la sua 'visione', il punto più alto raggiunto dalla già monumentale opera di propaganda fotografica dei Bildberichter, i fotografi di guerra tedeschi. Le fotografie, selezionate tra migliaia di scatti, rappresentano non solo una eccezionale testimonianza storica e estetica dei militari tedeschi della Heer, delle Waffen-SS, della Kriegsmarine e della Luftwaffe impegnati su tutti i fronti e delle loro gesta, ma anche una precisa indagine, tramite un profondo sguardo fotografico sugli 'occhi specchio dell'anima' di questi uomini in guerra, sulle radici identitarie dell'Uomo e del Soldato tedesco, come membro scelto di una coesa comunità nazionale e politica, impegnato nella difesa dei valori culturali tedeschi ed europei minacciati dal bolscevismo dell'Unione Sovietica da una parte, e dal capitalismo angloamericano dall'altra.",
      "prezzo": "22,80 euro",
      "link_IBS": "https://www.ibs.it/vero-volto-del-soldato-tedesco-libro-fritz-kempe/e/9788894226522"
    }, {
      "titolo": "La caduta di Berlino",
      "sottotitolo": "L'ultima battaglia di Hitler",
      "autore": "Werner Haupt",
      "pagine": "278 p., ill. , Brossura",
      "anno di pubblicazione": "2020",
      "descrizione": "Un classico della storia militare, coniugante l'accuratezza della documentata ricostruzione storica degli ultimi combattimenti per Berlino dell'aprile-maggio 1945, dallo sfondamento sovietico sull'Oder sino alla battaglia di Seelow e la difesa finale della capitale del III Reich, e l'avvincente narrazione delle vicende di un pugno di carristi della Panzer-Division 'Müncheberg' e volontari francesi dell'SS-Sturmbataillon 'Charlemagne', tra gli ultimi difensori di Berlino. Questa edizione presenta una traduzione rivista e annotata a cura del Wehrmacht Research Group, ed è integrata da nuove dettagliate mappe delle operazioni, drammatiche fotografie in azione dell'epoca, immagini attuali dei luoghi dei combattimenti e di illustrazioni a colori.",
      "prezzo": "23,75 euro",
      "link_IBS": "https://www.ibs.it/caduta-di-berlino-ultima-battaglia-libro-werner-haupt/e/9788831430012"
    }],
    // Proprietà windowWidth per salvare la dimensione dello schermo (passaggio 1)
    windowWidth: 0,

    /* Se fosse stato un oggetto con altezza e larghezza:
    window: {
        width: 0,
        height: 0
      } */
    normalWidth: true,
    specialWidth: false,
    duoWidth: false,
    monoWidth: false,
    // Proprietà larghezza bookDetails
    bookDetails: 0
  },

  /* Controlla la larghezza dello schermo in modo dinamico da quando viene caricata o distrutta
  l'istanza Vue (mounted e destroyed) tramite il richiamo della funzione handleResize
  (passaggio 3) */
  mounted: function mounted() {
    window.addEventListener('resize', this.handleResize);
    this.handleResize();
    window.addEventListener('resize', this.bookDetailsResize);
    this.bookDetailsResize();
  },
  destroyed: function destroyed() {
    window.removeEventListener('resize', this.handleResize);
  },
  methods: {
    nextImg: function nextImg() {
      this.counter++;

      if (this.counter === this.images.length) {
        this.counter = 0;
      }
    },
    prevImg: function prevImg() {
      if (this.counter > 0) {
        this.counter--;
      } else {
        this.counter = this.images.length - 1;
      }
    },
    slideBullet: function slideBullet() {
      // Selezioniamo dal Dom i dots
      var dots = document.querySelectorAll('carousel_bullet'); // Rimuoviamo la classe selected da tutti gli elementi

      for (var i = 0; i < dots.length; i++) {
        dots[i].classList.remove('selected');
      }

      var currentIndex = 0; // Salviamo l'indice dell'elemento attivo --> variabile currentIndex

      dots.forEach(function (element, index) {
        if (element === document.activeElement) {
          currentIndex = index;
        }
      }); // Aggiungiamo la classe selected all'elemento attivo

      dots[currentIndex].classList.add('selected'); // Aggiorniamo il counter

      this.counter = currentIndex;
    },

    /* Controlla la larghezza dello schermo e passa il valore alla funzione resize a mounted e destroyed.
    Il valore di width in data viene aggiornato da 0 a valore corrente.
    (passaggio 2) */
    handleResize: function handleResize() {
      this.windowWidth = window.screen.width;
    }
  },
  watch: {
    // Quando il valore di windowWidth cambia, fai partire questa funzione
    windowWidth: function windowWidth() {
      // Sezione JUMBOTRON
      // Se lo schermo ha una larghezza compresa tra 625px e 999px vanno cambiati l'HTML e il top% del titolo
      var jumboTitleParent = document.getElementsByClassName('main_title');

      if (this.windowWidth >= 300 && this.windowWidth < 1000) {
        // Eliminiamo il nodo che contiene il titolo formattato male selezionando il genitore
        jumboTitleParent[0].children[1].remove(); // Sostituiamo con l'HTML che divide il titolo in due 

        jumboTitleParent[0].innerHTML = '<img src="public/img/Background.jpg" class="fadeIn at-item"> <h1 class="special_title"> ITALIA </h1> <br> <h1 class="special_title_second"> Storica </h1>';
      } else {
        // Ripristiniamo l'HTML originale
        jumboTitleParent[0].innerHTML = '<img src="public/img/Background.jpg" class="fadeIn at-item"> <h1> ITALIA Storica </h1>';
      } // Sezione CORE
      // Salva in una variabile l'elemento HTML che ha id book_change


      var column = document.getElementById("book_change");
      /* Se la larghezza dello schermo è uguale o inferiore di 1200px aggiungi le classi order-last e order-css
      se c'è, rimuovi la classe order-first */

      if (this.windowWidth < 1200) {
        column.classList.add("order-last");
        column.classList.add("order-css");
        column.classList.toggle("order-first", false);
        /* Altrimenti, se larghezza dello schermo è maggiore di 1200px aggiungi la classe order-first
        se c'è, rimuovi le classi order-last e order-css */
      } else {
        column.classList.add("order-first");
        column.classList.toggle("order-last", false);
        column.classList.toggle("order-css", false);
      } // // Selezioniamo l'img della copertina attiva
      // let cover = document.getElementsByClassName("active");
      // let coverChild = cover[0].childNodes;
      // let coverArray = Array.from(coverChild);
      // Sezione ORDER

      /* Quando lo schermo è >= 2000px allora vengono eliminati div che contengono le card e le card assumono le classi card xl-4 lg-4 */

      /* Quando lo schermo è < 2000px allora vengono ripristinati i div originali e le card non hanno più le classi xl-4 e lg-4 */
      // Salva in una variabile l'elemento HTML con classe card container


      var cardContainer = document.getElementsByClassName('card-container'); // Salva in una variabile gli elementi HTML con classe card

      var cardsPosition = document.querySelectorAll('.card'); // Trasformiamo cardsPosition in Array

      var cardsPositionArray = Array.from(cardsPosition); // Cloniamo i nodi delle cards + discendenti   

      var cloneNode = cardsPositionArray[0].cloneNode(true);
      var cloneNode1 = cardsPositionArray[1].cloneNode(true);
      var cloneNode2 = cardsPositionArray[2].cloneNode(true);

      if (this.windowWidth >= 2000) {
        // Eliminiamo i parent nodes con le card
        cardContainer[0].children[0].remove();
        cardContainer[0].children[1].remove();
        cardContainer[0].children[0].remove(); // Visualizziamo le card senza parent nodes

        cardContainer[0].appendChild(cloneNode);
        cardContainer[0].appendChild(cloneNode1);
        cardContainer[0].appendChild(cloneNode2); // Aggiungiamo le classi a tutte le card (abbiamo adesso la struttura div = "card col-xl-4 col-lg-4")

        for (var i = 0; i < cardsPositionArray.length; i++) {
          cloneNode.classList.add("col-xl-4");
          cloneNode.classList.add("col-lg-4");
          cloneNode1.classList.add("col-xl-4");
          cloneNode1.classList.add("col-lg-4");
          cloneNode2.classList.add("col-xl-4");
          cloneNode2.classList.add("col-lg-4");
        }
      } else if (this.windowWidth < 2000) {
        // Elimina tutto il codice html delle card 
        cardContainer[0].children[0].remove();
        cardContainer[0].children[1].remove();
        cardContainer[0].children[0].remove(); // Ripristiniamo i "vecchi" parent nodes con le card copiando pari l'HTML originale (nota l'operatore +=)

        cardContainer[0].innerHTML += ' <div class="col-xl-4 col-lg-4"> <div class="card"> <div class="card-body text-center"> <i class="fas fa-book-open"></i> <hr> <h5 class="card-title"> SCARICA IL CATALOGO </h5> <hr> <p class="card-text text-center"> I NOSTRI LIBRI <br> STORICO-MILITARI <br>' + '<br> </p> <a href="https://1drv.ms/b/s!Aso8wGv5JN2egTHUDRwYrytfCIgJ" class="btn button orange btn-lg">Scarica il catalogo in PDF</a> </div> </div> </div> ' + ' <div class="col-xl-4 col-lg-4"><div class="card"> <div class="card-body text-center"> <i class="fas fa-bookmark"> </i> <hr> <h5 class="card-title">ORDINA SU IBS</h5><hr> <p class="card-text text-center"> I NOSTRI LIBRI <br> STORICO-MILITARI <br>' + '<br> </p> <a href="https://www.ibs.it/libri/editori/italia-storica" class="btn button orange btn-lg"> Vai su IBS.it</a> </div> </div> </div> </hr>' + ' <div class="col-xl-4 col-lg-4"> <div class="card"> <div class="card-body text-center"> <i class="fas fa-swatchbook"></i> <hr> <h5 class="card-title">ORDINA DA DISTRIBUTORE</h5> <hr> <p class="card-text"> I NOSTRI LIBRI <br> STORICO-MILITARI <br>' + '<br> </p> <a href="https://www.libroco.it/servizi-per-librai-acquisto-libri-on-line.php" class="btn button orange btn-lg"> Vai su LibroCo.it</a> </div> </div> </div> ';
      } // Sezione PERSONAL
      // Cambio template dei loghi


      if (this.windowWidth >= 992 && this.windowWidth <= 1550) {
        this.specialWidth = true;
        this.normalWidth = false;
        this.duoWidth = false;
        this.monoWidth = false;
      } else if (this.windowWidth >= 650 && this.windowWidth <= 991) {
        this.duoWidth = true;
        this.specialWidth = false;
        this.normalWidth = false;
        this.monoWidth = false;
      } else if (this.windowWidth <= 649) {
        this.monowidth = true;
        this.normalWidth = false;
        this.specialWidth = false;
        this.duoWidth = false;
      } else {
        this.normalWidth = true;
        this.specialWidth = false;
        this.duoWidth = false;
        this.monoWidth = false;
      } // Sezione FORM


      var map = document.getElementById("map-container");
      var form = document.getElementById("form-container");
      /* Se la larghezza dello schermo è uguale o inferiore di 1650px aggiungi la classe col-lg-12 a form e map
      se c'è, rimuovi la classe col-lg-8 da form e classe col-lg-4 da map */

      if (this.windowWidth <= 1650) {
        form.classList.add("col-lg-12");
        form.classList.toggle("col-lg-8", false);
        map.classList.add("col-lg-12");
        map.classList.toggle("col-lg-4", false);
        /* Altrimenti, se larghezza dello schermo è maggiore di 1650px aggiungi le classi col-lg-8 a form e col-lg-4 a map
        se c'è, rimuovi la classe col-lg-12 a entrambi */
      } else {
        form.classList.add("col-lg-8");
        form.classList.toggle("col-lg-12", false);
        map.classList.add("col-lg-4");
        map.classList.toggle("col-lg-12", false);
      }
    },
    // Quando il valore del counter (che gestisce i radiobutton e le copertine) cambia, fai partire questa funzione e aggiorna la posizione dei radiobutton
    counter: function counter() {
      /* Dobbiamo tenere fixed la posizione dei radiobutton del carosello modificando la proprietà bottom */
      // // Salviamo tramite id il div controllore di tutti i radiobutton (variabile allRadiobuttons)
      // let allRadiobuttons = document.getElementById('radiobuttonController');
      // // Selezioniamo i valori posizionali dei radiobutton
      // let valuesB = allRadiobuttons.getBoundingClientRect().bottom;
      // let valuesT = allRadiobuttons.getBoundingClientRect().top;
      // let valuesY = allRadiobuttons.getBoundingClientRect().y;
      // let allValues = allRadiobuttons.getBoundingClientRect();
      // console.log(allValues);
      // // Queste sono i valori pozionali dei radiobutton quando counter = 0 (costanti)
      // const rdbB = 1382.449951171875;
      // const rdbT = 1382.449951171875;
      // const rdbY = 1302.5999755859375;
      // if ((valuesY != rdbY) ||  (valuesT != rdbT) || (valuesB != rdbB)) {
      //     valuesY == rdbY;
      //     valuesT == rdbT;
      //     valuesB == rdbB;
      // }
    }
  }
});
/*=====  End of VUE SECTION block  ======*/

/*=================================================
=            VANILLA JAVASCRIPT SECTION           =
==================================================*/

/*----------  Subsection Card outline colors  ----------*/

/* Quando i buttons delle card sono on hover allora l'outline delle card e le icone fontawesome cambiano colore */
// Selezioniamo i buttons delle card (nodeList)

var buttons = document.querySelectorAll('.card .orange'); // Trasformiamo buttons in Array

var buttonsArray = Array.from(buttons); // Selezioniamo gli elementi da cambiare (nodeList)

var iconsFas = document.querySelectorAll('.card .fas');
var cards = document.querySelectorAll('.card'); // Creiamo i cicli con i Listener e le funzioni per cambiare i colori

var _loop = function _loop(i) {
  buttonsArray[i].addEventListener('mouseover', function () {
    iconsFas[i].style.color = 'rgb(244, 124, 32)';
    cards[i].style.outlineColor = 'rgb(244, 124, 32)';
  });
};

for (var i = 0; i < buttonsArray.length; i++) {
  _loop(i);
}

;

var _loop2 = function _loop2(_i) {
  buttonsArray[_i].addEventListener('mouseleave', function () {
    iconsFas[_i].style.color = 'rgb(250, 153, 28)';
    cards[_i].style.outlineColor = 'rgb(250, 153, 28)';
  });
};

for (var _i = 0; _i < buttonsArray.length; _i++) {
  _loop2(_i);
}

;
/*---------- End Subsection Card outline colors  ----------*/

/*----------  Subsection Validation Form  ----------*/
// Validation test + Invio mail

function controlloForm() {
  // Selezioniamo la mail inserita nel form e la salviamo in una variabile
  var name = document.getElementById('namesurname').value;
  var email = document.getElementById('email').value;
  var subject = document.getElementById('subject').value;
  var mailbody = document.getElementById('mailbody').value; // Variabile di tipo regExp - oggetto Javascript
  // Espressione regolare per l'email (username + @ + dominio + . + estensione del dominio TLD )

  var regx = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]{2,10})$/;
  var regEmail = regx.test(email); // Verifica l'espressione regolare.

  console.log(regEmail); // Se tutto è ok, convalida i dati e inviali alla pagina

  if (regEmail) {
    // Costruiamo l'oggetto che conterrà i dati da inviare
    var formdata = {};
    formdata = {
      name: name,
      email: email,
      subject: subject,
      message: mailbody
    }; // Trasformiamo formdata in un oggetto Json

    var jason = JSON.stringify(formdata).serializeArray(); // Chiamata AJAX al server

    var xhr = new XMLHttpRequest();
    xhr.open("POST", "form.php", true);

    xhr.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        console.log("Grazie ".concat(name, " per averci scritto. Ti risponderemo al pi\xF9 presto."));
      }
    };

    xhr.setRequestHeader("Content-type", "multipart/form-data;", "charset=UTF-8");

    xhr.onerror = function () {
      console.log(this.status, this.statusText);
    };

    xhr.send(jason); // Se falso l'indirizzo mail è scritto sbagliato       
  } else {
    // Selezioniamo il div con il messaggio di errore (displayNone)
    var invalidEmail = document.querySelector('.error'); // Rendiamo visibile il div

    invalidEmail.setAttribute('style', 'display:inline-block !important'); // Impostiamo l'outline color di errore

    var invalidInput = document.getElementById('email');
    invalidInput.style.outline = "thin solid rgb(244, 124, 32)"; // Usciamo dalla funzione senza inviare il file

    return false;
  }
}
/*---------- End Subsection Validation Form  ----------*/

/*---------- Subsection Carousel  ----------*/
// Select all slides


var slides = document.querySelectorAll(".slide"); // current slide counter

var curSlide = 0; // maximum number of slides

var maxSlide = slides.length - 1; // select next slide button

var nextSlide = document.querySelector(".btn-next"); // add event listener and navigation functionality

nextSlide.addEventListener("click", function () {
  // check if current slide is the last and reset current slide
  if (curSlide === maxSlide) {
    curSlide = 0;
  } else {
    curSlide++;
  } // gestione classe selected


  slides[curSlide].classList.add("selected");

  if (slides[curSlide - 1] !== undefined) {
    slides[curSlide - 1].classList.remove("selected");
  } // se sia l'elemento 0 che l'elemento massimo dell'array hanno la classe selected, toglila all'elemento massimo


  if (curSlide == 0 && slides[maxSlide].classList.contains("selected")) {
    slides[maxSlide].classList.remove("selected");
  }
}); // select prev slide button

var prevSlide = document.querySelector(".btn-prev"); // add event listener and navigation functionality

prevSlide.addEventListener("click", function () {
  // check if current slide is the first and reset current slide to last
  if (curSlide === 0) {
    curSlide = maxSlide;
  } else {
    curSlide--;
  } // gestione classe selected


  slides[curSlide].classList.add("selected");

  if (slides[curSlide + 1] !== undefined) {
    slides[curSlide + 1].classList.remove("selected");
  } // se sia l'elemento 0 che l'elemento massimo dell'array hanno la classe selected, toglila all'elemento 0


  if (curSlide == maxSlide && slides[0].classList.contains("selected")) {
    slides[0].classList.remove("selected");
  }
}); // loop through slides and set each slides translateX property to index * 100% 
// slides.forEach((slide, index) => {
//   slide.style.transform = `translateX(${index * 100}%)`;
// });
// if (window.screen.width >= 400 || window.screen.width <=  1199) {
//     slides.forEach((slide, index) => {
//         let shift = index - curSlide;
//         slide.style.transform = `translateX(${100 * 3 * (shift)}%)`;
//         slide.classList.remove('active');
//     });
// }
// if (window.screen.width >= 400 || window.screen.width <=  1199) {
//     slides.forEach((slide, index) => {
//         let shift = index - curSlide;
//         slide.style.transform = `translateX(${100 * 3 * (shift)}%)`;
//         slide.classList.remove("active");
//     });
// }
//   move slide by 100% e remove class active
// slides.forEach((slide, index) => {
//     slide.style.transform = `translateX(${100 * (index - curSlide)}%)`;
//     slide.classList.remove("active");
// });
// move slide by -100% e remove class active
//   slides.forEach((slide, index) => {
//     slide.style.transform = `translateX(${100 * (index - curSlide)}%)`;
//     slide.classList.remove("active");
//   });

/*---------- End Subsection Carousel  ----------*/

/*=====  End of VANILLA JAVASCRIPT SECTION ======*/

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/mediaquery.scss":
/*!*****************************!*\
  !*** ./src/mediaquery.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/main_vue": 0,
/******/ 			"css/style": 0,
/******/ 			"css/mediaquery": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkmyapp"] = self["webpackChunkmyapp"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/style","css/mediaquery"], () => (__webpack_require__("./src/main_vue.js")))
/******/ 	__webpack_require__.O(undefined, ["css/style","css/mediaquery"], () => (__webpack_require__("./src/style.scss")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/style","css/mediaquery"], () => (__webpack_require__("./src/mediaquery.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;